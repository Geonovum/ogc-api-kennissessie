extends layout.pug

block append scripts
  link(rel='stylesheet' href='https://unpkg.com/leaflet@1.6.0/dist/leaflet.css')
  script(src='https://unpkg.com/leaflet@1.6.0/dist/leaflet.js')

block header

  svg.d-none(xmlns='http://www.w3.org/2000/svg')
    symbol#house-door-fill(viewbox='0 0 16 16')
      path(d='M6.5 14.5v-3.505c0-.245.25-.495.5-.495h2c.25 0 .5.25.5.5v3.5a.5.5 0 0 0 .5.5h4a.5.5 0 0 0 .5-.5v-7a.5.5 0 0 0-.146-.354L13 5.793V2.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v1.293L8.354 1.146a.5.5 0 0 0-.708 0l-6 6A.5.5 0 0 0 1.5 7.5v7a.5.5 0 0 0 .5.5h4a.5.5 0 0 0 .5-.5z')

  - let linkSelf = content.links.find(i => i.rel == 'self').href.split('?')[0]
  - let links = [ linkSelf ]
  - while (links[0] != serviceUrl) {
  -  links.unshift(links[0].substr(0, links[0].lastIndexOf("/"))) }

  nav.navbar.navbar-light.bg-light.navbar-expand-sm
    .container
      #navbar.navbar-collapse.collapse.d-flex.justify-content-between.align-items-center
        ol.breadcrumb.breadcrumb-chevron.p-3.bg-light
          li.breadcrumb-item
            a.link-body-emphasis(href=serviceUrl)
              svg.bi(width='16' height='16')
                use(xlink:href='#house-door-fill')
              span.visually-hidden serviceUrl
          li.breadcrumb-item
            a.link-body-emphasis.fw-semibold.text-decoration-none(href=links[1]) Data
          - let pathElement = links[2].substring(links[2].lastIndexOf("/") + 1);
          li.breadcrumb-item
            a.link-body-emphasis.fw-semibold.text-decoration-none(href=links[2]) #{pathElement}
          li.breadcrumb-item.active(aria-current='page')
            | Items
        ul.list-separated.m-0.p-0
          a(href=linkSelf + '?f=json') JSON

block content

  .container.py-4
    .row
      .col-sm-12
        br
        section#collection
          .row
            .col-sm
              h1 Items
                
        if (content.numberMatched > content.numberReturned)
          - let firstLink = content.links.find(i => i.rel == 'first')
          - let prevLink  = content.links.find(i => i.rel == 'prev')
          - let nextLink  = content.links.find(i => i.rel == 'next')
          - let lastLink  = content.links.find(i => i.rel == 'last')
          - let selfLink  = content.links.find(i => i.rel == 'self')
          
          // Extract offset and limit from the self link URL
          - let selfUrl = new URL(selfLink.href)
          - let currentOffset = parseInt(selfUrl.searchParams.get('offset')) || 0
          - let currentLimit = parseInt(selfUrl.searchParams.get('limit')) || 10
          
          // Calculate current page (1-based)
          - let currentPage = Math.floor(currentOffset / currentLimit) + 1
          - let totalPages = Math.ceil(content.numberMatched / currentLimit)
          - let startPage = Math.max(1, currentPage - 2)
          - let endPage = Math.min(totalPages, currentPage + 2)
          

          .d-flex.justify-content-between.align-items-center.mb-3
            .pagination-controls
              nav(aria-label='Pagination')
                ul.pagination.mb-0
                  // First page
                  if firstLink
                    li.page-item
                      a.page-link(href=firstLink.href title=firstLink.title) «
                  else
                    li.page-item.disabled
                      span.page-link ‹

                  // Previous page
                  if prevLink
                    li.page-item
                      a.page-link(href=prevLink.href title=prevLink.title) ‹
                  else
                    li.page-item.disabled
                      span.page-link ‹

                  // Page numbers
                  - var p = startPage;
                  while p <= endPage
                    if p == currentPage
                      li.page-item.active
                        span.page-link #{p}
                    else
                      - let pageUrl = new URL(selfUrl.toString())
                      - pageUrl.searchParams.set('offset', (p - 1) * currentLimit)
                      li.page-item
                        a.page-link(href=pageUrl.toString()) #{p}
                    - p++

                  // Next page
                  if nextLink
                    li.page-item
                      a.page-link(href=nextLink.href title=nextLink.title) ›
                  else
                    li.page-item.disabled
                      span.page-link ›

                  // Last page
                  if lastLink
                    li.page-item
                      a.page-link(href=lastLink.href title=lastLink.title) »
                  else
                    li.page-item.disabled
                      span.page-link »


    .row
      .col-md-6
        ul.list-unstyled
          - var n = 0;
          while n < content.numberReturned
            - var feature = content.features[n]
            li
              - n++
              div
                h4.mt-3.mb-1
                  a(href=linkSelf + '/' + n)
                    span #{feature.properties.fid}
                span.d-none linkSelf + '/' + n
                .row.my-1
                  .col-md-6.font-weight-bold.text-truncate(data-property='id')
                    span(style='vertical-align: middle;') #{feature.type}
                  .col-md-6
                    ul.list-unstyled
                      li #{n}  

      .col-md-6
        #map(style='width: 540px; height: 480px; position: relative;')
        script.
          // Calculate spatial extent (bounding box) from features
          const features = !{JSON.stringify(content.features)};
          let coords = null;
          
          if (features.length > 0) {
            // Calculate bounding box from features
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            let hasGeometry = false;
            
            features.forEach(feature => {
              if (feature.geometry && feature.geometry.coordinates) {
                hasGeometry = true;
                const coords = feature.geometry.coordinates;
                
                if (feature.geometry.type === 'Point') {
                  const [x, y] = coords;
                  minX = Math.min(minX, x);
                  minY = Math.min(minY, y);
                  maxX = Math.max(maxX, x);
                  maxY = Math.max(maxY, y);
                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiPoint') {
                  coords.forEach(coord => {
                    const [x, y] = coord;
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                  });
                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiLineString') {
                  coords.forEach(ring => {
                    ring.forEach(coord => {
                      const [x, y] = coord;
                      minX = Math.min(minX, x);
                      minY = Math.min(minY, y);
                      maxX = Math.max(maxX, x);
                      maxY = Math.max(maxY, y);
                    });
                  });
                } else if (feature.geometry.type === 'MultiPolygon') {
                  coords.forEach(polygon => {
                    polygon.forEach(ring => {
                      ring.forEach(coord => {
                        const [x, y] = coord;
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                      });
                    });
                  });
                }
              }
            });
            
            if (hasGeometry) {
              coords = [minX, minY, maxX, maxY];
            }
          }
          
          let bounds, centerx, centery;
          if (coords) {
            bounds = [[coords[1], coords[0]], [coords[3], coords[2]]];
            centerx = (parseFloat(coords[2]) + parseFloat(coords[0])) / 2;
            centery = (parseFloat(coords[3]) + parseFloat(coords[1])) / 2;
          } else {
            // Default bounds if no features or no geometry
            bounds = [[0, 0], [0, 0]];
            centerx = 0;
            centery = 0;
          }

          const map = L.map("map").setView([centery, centerx], 10);

          L.tileLayer('http://tile.openstreetmap.org/{z}/{x}/{y}.png', {attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'}).addTo(map);

          // Add features to the map (features already declared above)
          
          // Create a GeoJSON layer for the features
          const featureLayer = L.geoJSON(features, {
            pointToLayer: function (feature, latlng) {
              // Style points
              return L.circleMarker(latlng, {
                radius: 6,
                fillColor: "#ff7800",
                color: "#000",
                weight: 1,
                opacity: 1,
                fillOpacity: 0.8
              });
            },
            style: function (feature) {
              // Style lines and polygons
              return {
                color: "#ff7800",
                weight: 2,
                opacity: 0.8,
                fillOpacity: 0.3
              };
            },
            onEachFeature: function (feature, layer) {
              // Add popup with feature properties
              let popupContent = '<div class="feature-popup">';
              popupContent += '<h6>Feature Properties:</h6>';
              popupContent += '<ul class="list-unstyled">';
              
              // Display all properties
              for (let prop in feature.properties) {
                if (feature.properties.hasOwnProperty(prop)) {
                  popupContent += `<li><strong>${prop}:</strong> ${feature.properties[prop]}</li>`;
                }
              }
              
              popupContent += '</ul>';
              popupContent += '</div>';
              
              layer.bindPopup(popupContent);
            }
          }).addTo(map);

          // Fit map to show all features
          if (features.length > 0) {
            map.fitBounds(featureLayer.getBounds(), {padding: [10, 10]});
          }