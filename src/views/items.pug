extends layout.pug

block append scripts
  link(rel='stylesheet' href='https://unpkg.com/leaflet@1.6.0/dist/leaflet.css')
  script(src='https://unpkg.com/leaflet@1.6.0/dist/leaflet.js')

block header

  svg.d-none(xmlns='http://www.w3.org/2000/svg')
    symbol#house-door-fill(viewbox='0 0 16 16')
      path(d='M6.5 14.5v-3.505c0-.245.25-.495.5-.495h2c.25 0 .5.25.5.5v3.5a.5.5 0 0 0 .5.5h4a.5.5 0 0 0 .5-.5v-7a.5.5 0 0 0-.146-.354L13 5.793V2.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v1.293L8.354 1.146a.5.5 0 0 0-.708 0l-6 6A.5.5 0 0 0 1.5 7.5v7a.5.5 0 0 0 .5.5h4a.5.5 0 0 0 .5-.5z')

  - let linkSelf = content.links.find(i => i.rel == 'self').href.split('?')[0]
  - let links = [ linkSelf ]
  - while (links[0] != serviceUrl) {
  -  links.unshift(links[0].substr(0, links[0].lastIndexOf("/"))) }

  nav.navbar.navbar-light.bg-light.navbar-expand-sm
    .container
      #navbar.navbar-collapse.collapse.d-flex.justify-content-between.align-items-center
        ol.breadcrumb.breadcrumb-chevron.p-3.bg-light
          li.breadcrumb-item
            a.link-body-emphasis(href=serviceUrl)
              svg.bi(width='16' height='16')
                use(xlink:href='#house-door-fill')
              span.visually-hidden serviceUrl
          li.breadcrumb-item
            a.link-body-emphasis.fw-semibold.text-decoration-none(href=links[1]) Data
          - let pathElement = links[2].substring(links[2].lastIndexOf("/") + 1);
          li.breadcrumb-item
            a.link-body-emphasis.fw-semibold.text-decoration-none(href=links[2]) #{pathElement}
          li.breadcrumb-item.active(aria-current='page')
            | Items
        ul.list-separated.m-0.p-0
          a(href=linkSelf + '?f=json') JSON

block content

  .container.py-4
    .row
      .col-sm-12
        br
        section#collection
          .row
            .col-sm
              h1 Items
              p
                | #{content.description}
                
        if (content.numberMatched > content.numberReturned)
          //- Use pagination parameters passed from the controller
          - let selfLink = content.links.find(i => i.rel == 'self').href
          - var offset = options.offset || 0
          - var limit = options.limit || 10
          - var pageCount = Math.ceil(content.numberMatched / limit);
          - var pageActive = Math.trunc(offset / limit) + 1; // Convert to 1-based page numbering
          - var pageFirst = Math.max(1, pageActive - 2); 
          - var pageLast  = Math.min(pageCount, pageFirst + 4); 

          //- Build base URL for pagination links
          - let baseUrl = selfLink.split('?')[0]
          //- Extract existing query parameters (like format)
          - let queryString = selfLink.includes('?') ? selfLink.split('?')[1] : ''
          - let queryParams = new URLSearchParams(queryString)

          //- Debug info (can be removed in production)
          //- p Debug: offset=#{offset}, limit=#{limit}, pageCount=#{pageCount}, pageActive=#{pageActive}
          //- p Debug: pageFirst=#{pageFirst}, pageLast=#{pageLast}

          nav(aria-label='...')
            ul.pagination

              //- First page link
              if pageActive == 1
                li.page-item.disabled
                  a.page-link(href='#') «
              else
                - queryParams.set('offset', '0')
                - let firstUrl = baseUrl + '?' + queryParams.toString()
                li.page-item
                  a.page-link(href=firstUrl) «

              //- Previous page link
              if pageActive == 1
                li.page-item.disabled
                  a.page-link(href='#') ‹
              else
                - let prevOffset = Math.max(0, offset - limit)
                - queryParams.set('offset', prevOffset.toString())
                - let prevUrl = baseUrl + '?' + queryParams.toString()
                li.page-item
                  a.page-link(href=prevUrl) ‹

              //- Numbered page links
              - var p = pageFirst;
              while p <= pageLast
                if p == pageActive
                  li.page-item.active
                    a.page-link(href='#') #{p}
                else
                  - let pageOffset = (p - 1) * limit
                  - queryParams.set('offset', pageOffset.toString())
                  - let pageUrl = baseUrl + '?' + queryParams.toString()
                  li.page-item
                    a.page-link(href=pageUrl) #{p}
                - p++

              //- Next page link
              if pageActive >= pageCount
                li.page-item.disabled
                  a.page-link(href='#') ›
              else
                - let nextOffset = offset + limit
                - queryParams.set('offset', nextOffset.toString())
                - let nextUrl = baseUrl + '?' + queryParams.toString()
                li.page-item
                  a.page-link(href=nextUrl) ›

              //- Last page link
              if pageActive >= pageCount
                li.page-item.disabled
                  a.page-link(href='#') »
              else
                - let lastOffset = (pageCount - 1) * limit
                - queryParams.set('offset', lastOffset.toString())
                - let lastUrl = baseUrl + '?' + queryParams.toString()
                li.page-item
                  a.page-link(href=lastUrl) »


    .row
      .col-md-6
        ul.list-unstyled
          - var n = 0;
          while n < content.numberReturned
            - var feature = content.features[n]
            li
              - n++
              div
                h4.mt-3.mb-1
                  a(href=linkSelf + '/' + feature.id)
                    span #{feature.id}
                
                // Display all properties
                .properties-container.mt-2
                  ul.list-unstyled
                    each value, key in feature.properties
                      if (key != 'links')
                        li.property-item.mb-1
                          strong #{key}: 
                          span #{value}  

      .col-md-6
        #map(style='width: 540px; height: 480px; position: relative;')
        script.
          const coords = !{JSON.stringify(content.extent.spatial.bbox)}
          const bounds = [[coords[1], coords[0]], [coords[3], coords[2]]];

          const centerx = (parseFloat(coords[2]) + parseFloat(coords[0])) / 2
          const centery = (parseFloat(coords[3]) + parseFloat(coords[1])) / 2

          const map = L.map("map").setView([centery, centerx], 10);

          L.tileLayer('http://tile.openstreetmap.org/{z}/{x}/{y}.png', {attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'}).addTo(map);

          // Add features to the map
          const features = !{JSON.stringify(content.features)};
          
          // Create a GeoJSON layer for the features
          const featureLayer = L.geoJSON(features, {
            pointToLayer: function (feature, latlng) {
              // Style points
              return L.circleMarker(latlng, {
                radius: 6,
                fillColor: "#ff7800",
                color: "#000",
                weight: 1,
                opacity: 1,
                fillOpacity: 0.8
              });
            },
            style: function (feature) {
              // Style lines and polygons
              return {
                color: "#ff7800",
                weight: 2,
                opacity: 0.8,
                fillOpacity: 0.3
              };
            },
            onEachFeature: function (feature, layer) {
              // Add popup with feature properties
              let popupContent = '<div class="feature-popup">';
              popupContent += '<h6>Feature Properties:</h6>';
              popupContent += '<ul class="list-unstyled">';
              
              // Display all properties
              for (let prop in feature.properties) {
                if (feature.properties.hasOwnProperty(prop)) {
                  popupContent += `<li><strong>${prop}:</strong> ${feature.properties[prop]}</li>`;
                }
              }
              
              popupContent += '</ul>';
              popupContent += '</div>';
              
              layer.bindPopup(popupContent);
            }
          }).addTo(map);

          // Fit map to show all features
          if (features.length > 0) {
            map.fitBounds(featureLayer.getBounds(), {padding: [10, 10]});
          }